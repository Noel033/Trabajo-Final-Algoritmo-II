import pygame
import sys
import random
from enum import Enum

# Inicializar Pygame
pygame.init()

# Constantes
WINDOW_WIDTH = 1200
WINDOW_HEIGHT = 800
FPS = 60

# Colores
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BLUE = (0, 100, 200)
GREEN = (0, 150, 0)
RED = (200, 0, 0)
GOLD = (255, 215, 0)
BROWN = (139, 69, 19)
PURPLE = (128, 0, 128)
DARK_BLUE = (25, 25, 112)
ORANGE = (255, 165, 0)

class GameState(Enum):
    INTRO = 1
    MAP = 2
    QUIZ = 3
    FINAL_CHALLENGE = 4
    VICTORY = 5

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        pygame.display.set_caption("La Travesía de Ekeko y Ai Apaec")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 36)
        self.small_font = pygame.font.Font(None, 28)
        self.large_font = pygame.font.Font(None, 48)
        
        self.state = GameState.INTRO
        self.current_apu = 0
        self.illas_recovered = 0
        
        # Lista de Illas robadas
        self.illas = [
            "Tumi", "Chacana", "Illa", "Torito", "Perro Viringo", "Cuy", 
            "Qullqi", "Quispe", "Qori", "Chuño", "Papa", "Maíz", 
            "Calluha", "Cungalpo", "Hizanche", "Huashacara", "Inti", "Killa", "Chaska"
        ]
        
        # APUs y sus preguntas
        self.apus = [
            {
                "name": "Huascarán",
                "description": "El amante de la historia",
                "category": "Historia",
                "question": "¿Qué civilización preincaica es conocida por sus líneas trazadas en el desierto?",
                "options": ["A) Mochica", "B) Nazca", "C) Chavín", "D) Wari"],
                "correct": 1,
                "color": BLUE
            },
            {
                "name": "Misti",
                "description": "El protector de la cocina",
                "category": "Gastronomía",
                "question": "¿Cuál plato peruano se prepara con pescado crudo marinado en limón?",
                "options": ["A) Lomo saltado", "B) Ceviche", "C) Anticucho", "D) Ají de gallina"],
                "correct": 1,
                "color": RED
            },
            {
                "name": "Salkantay",
                "description": "Guardián de las lenguas",
                "category": "Lenguas Originarias",
                "question": "¿Qué lengua originaria se habla en gran parte del Perú además del español?",
                "options": ["A) Mapudungun", "B) Quechua", "C) Guaraní", "D) Aymara"],
                "correct": 1,
                "color": GREEN
            },
            {
                "name": "Coropuna",
                "description": "El más alto de los volcanes",
                "category": "Geografía",
                "question": "¿Cuál es el nevado más alto del Perú?",
                "options": ["A) Misti", "B) Salkantay", "C) Huascarán", "D) Ausangate"],
                "correct": 2,
                "color": PURPLE
            },
            {
                "name": "Ampato",
                "description": "Conocido por sus tesoros arqueológicos",
                "category": "Festividades",
                "question": "¿En qué ciudad se celebra la fiesta de la Virgen de la Candelaria?",
                "options": ["A) Cusco", "B) Puno", "C) Arequipa", "D) Trujillo"],
                "correct": 1,
                "color": ORANGE
            }
        ]
        
        self.selected_option = 0
        self.show_result = False
        self.result_timer = 0
        self.last_answer_correct = False
        
        # Para el desafío final
        self.final_values = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
        self.final_options = ["A) 6", "B) 4", "C) 7", "D) 8"]
        self.final_correct = 0
        
    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            
            if event.type == pygame.KEYDOWN:
                if self.state == GameState.INTRO:
                    if event.key == pygame.K_SPACE:
                        self.state = GameState.MAP
                
                elif self.state == GameState.MAP:
                    if event.key == pygame.K_SPACE and self.current_apu < len(self.apus):
                        self.state = GameState.QUIZ
                        self.selected_option = 0
                        self.show_result = False
                    elif event.key == pygame.K_SPACE and self.current_apu >= len(self.apus):
                        self.state = GameState.FINAL_CHALLENGE
                        self.selected_option = 0
                        self.show_result = False
                
                elif self.state == GameState.QUIZ or self.state == GameState.FINAL_CHALLENGE:
                    if not self.show_result:
                        if event.key == pygame.K_UP:
                            self.selected_option = max(0, self.selected_option - 1)
                        elif event.key == pygame.K_DOWN:
                            max_options = 4 if self.state == GameState.QUIZ else len(self.final_options)
                            self.selected_option = min(max_options - 1, self.selected_option + 1)
                        elif event.key == pygame.K_RETURN:
                            self.check_answer()
                    else:
                        if event.key == pygame.K_SPACE:
                            if self.last_answer_correct:
                                if self.state == GameState.QUIZ:
                                    self.current_apu += 1
                                    self.illas_recovered += random.randint(3, 5)
                                    self.state = GameState.MAP
                                else:  # Final challenge
                                    self.state = GameState.VICTORY
                            else:
                                self.show_result = False
                                self.selected_option = 0
                
                elif self.state == GameState.VICTORY:
                    if event.key == pygame.K_SPACE:
                        self.__init__()  # Reiniciar juego
        
        return True
    
    def check_answer(self):
        if self.state == GameState.QUIZ:
            correct = self.apus[self.current_apu]["correct"]
            self.last_answer_correct = (self.selected_option == correct)
        else:  # Final challenge
            self.last_answer_correct = (self.selected_option == self.final_correct)
        
        self.show_result = True
        self.result_timer = pygame.time.get_ticks()
    
    def draw_intro(self):
        self.screen.fill(DARK_BLUE)
        
        # Título
        title = self.large_font.render("La Travesía de Ekeko y Ai Apaec", True, GOLD)
        title_rect = title.get_rect(center=(WINDOW_WIDTH//2, 150))
        self.screen.blit(title, title_rect)
        
        # Historia intro
        intro_text = [
            "Desde lo alto de los Andes, El Ekeko llega a la FIA",
            "reparte bendiciones a los estudiantes de la EPICS.",
            "",
            "¡Pero las Illas han sido robadas!",
            "Los APUs las guardan usando algoritmos de árboles binarios.",
            "",
            "Ayuda a Ekeko y Ai Apaec a recuperarlas",
            "respondiendo los acertijos de cada APU.",
            "",
            "Presiona ESPACIO para comenzar la aventura"
        ]
        
        y = 250
        for line in intro_text:
            if line:
                text = self.font.render(line, True, WHITE)
                text_rect = text.get_rect(center=(WINDOW_WIDTH//2, y))
                self.screen.blit(text, text_rect)
            y += 40
    
    def draw_map(self):
        self.screen.fill((20, 50, 80))  # Azul montaña
        
        # Título
        title = self.large_font.render("Mapa de los APUs", True, WHITE)
        title_rect = title.get_rect(center=(WINDOW_WIDTH//2, 50))
        self.screen.blit(title, title_rect)
        
        # Progreso
        progress_text = f"Illas recuperadas: {self.illas_recovered}/{len(self.illas)}"
        progress = self.font.render(progress_text, True, GOLD)
        self.screen.blit(progress, (50, 100))
        
        # Mostrar APUs
        if self.current_apu < len(self.apus):
            current = self.apus[self.current_apu]
            
            # Dibujar montaña (rectángulo simple)
            pygame.draw.rect(self.screen, current["color"], 
                           (WINDOW_WIDTH//2 - 100, 200, 200, 150))
            pygame.draw.polygon(self.screen, WHITE, 
                              [(WINDOW_WIDTH//2 - 50, 200), 
                               (WINDOW_WIDTH//2, 150), 
                               (WINDOW_WIDTH//2 + 50, 200)])
            
            # Nombre del APU
            name = self.large_font.render(f"APU {current['name']}", True, WHITE)
            name_rect = name.get_rect(center=(WINDOW_WIDTH//2, 400))
            self.screen.blit(name, name_rect)
            
            # Descripción
            desc = self.font.render(current["description"], True, WHITE)
            desc_rect = desc.get_rect(center=(WINDOW_WIDTH//2, 450))
            self.screen.blit(desc, desc_rect)
            
            # Categoría
            cat = self.font.render(f"Categoría: {current['category']}", True, GOLD)
            cat_rect = cat.get_rect(center=(WINDOW_WIDTH//2, 500))
            self.screen.blit(cat, cat_rect)
            
            # Instrucción
            instruction = self.font.render("Presiona ESPACIO para enfrentar el desafío", True, WHITE)
            instruction_rect = instruction.get_rect(center=(WINDOW_WIDTH//2, 600))
            self.screen.blit(instruction, instruction_rect)
        
        else:
            # Todos los APUs completados
            final_text = self.large_font.render("¡Todos los APUs visitados!", True, GOLD)
            final_rect = final_text.get_rect(center=(WINDOW_WIDTH//2, 300))
            self.screen.blit(final_text, final_rect)
            
            challenge_text = self.font.render("Los APUs Unidos presentan el desafío final", True, WHITE)
            challenge_rect = challenge_text.get_rect(center=(WINDOW_WIDTH//2, 400))
            self.screen.blit(challenge_text, challenge_rect)
            
            instruction = self.font.render("Presiona ESPACIO para el desafío definitivo", True, WHITE)
            instruction_rect = instruction.get_rect(center=(WINDOW_WIDTH//2, 500))
            self.screen.blit(instruction, instruction_rect)
    
    def draw_quiz(self):
        self.screen.fill((40, 40, 60))
        
        current = self.apus[self.current_apu]
        
        # Nombre del APU
        apu_name = self.large_font.render(f"APU {current['name']}", True, current["color"])
        apu_rect = apu_name.get_rect(center=(WINDOW_WIDTH//2, 80))
        self.screen.blit(apu_name, apu_rect)
        
        # Pregunta
        question_lines = self.wrap_text(current["question"], self.font, WINDOW_WIDTH - 100)
        y = 150
        for line in question_lines:
            text = self.font.render(line, True, WHITE)
            text_rect = text.get_rect(center=(WINDOW_WIDTH//2, y))
            self.screen.blit(text, text_rect)
            y += 40
        
        # Opciones
        y = 300
        for i, option in enumerate(current["options"]):
            color = GOLD if i == self.selected_option else WHITE
            if self.show_result:
                if i == current["correct"]:
                    color = GREEN
                elif i == self.selected_option and not self.last_answer_correct:
                    color = RED
            
            text = self.font.render(option, True, color)
            self.screen.blit(text, (200, y))
            y += 50
        
        if not self.show_result:
            instruction = self.small_font.render("Usa ↑↓ para seleccionar, ENTER para confirmar", True, WHITE)
            self.screen.blit(instruction, (50, 700))
        else:
            result_text = "¡Correcto!" if self.last_answer_correct else "Incorrecto. Inténtalo de nuevo."
            result_color = GREEN if self.last_answer_correct else RED
            result = self.font.render(result_text, True, result_color)
            result_rect = result.get_rect(center=(WINDOW_WIDTH//2, 600))
            self.screen.blit(result, result_rect)
            
            continue_text = self.small_font.render("Presiona ESPACIO para continuar", True, WHITE)
            continue_rect = continue_text.get_rect(center=(WINDOW_WIDTH//2, 650))
            self.screen.blit(continue_text, continue_rect)
    
    def draw_final_challenge(self):
        self.screen.fill((60, 20, 60))  # Púrpura místico
        
        # Título
        title = self.large_font.render("Desafío Final: Los APUs Unidos", True, GOLD)
        title_rect = title.get_rect(center=(WINDOW_WIDTH//2, 80))
        self.screen.blit(title, title_rect)
        
        # Pregunta
        question_text = [
            "Encuentra la suma máxima de un subarreglo contiguo:",
            "Lista de valores simbólicos: [-2, 1, -3, 4, -1, 2, 1, -5, 4]",
            "",
            "(Algoritmo de Kadane)"
        ]
        
        y = 150
        for line in question_text:
            if line:
                text = self.font.render(line, True, WHITE)
                text_rect = text.get_rect(center=(WINDOW_WIDTH//2, y))
                self.screen.blit(text, text_rect)
            y += 40
        
        # Visualización de la lista
        array_str = "[-2, 1, -3, 4, -1, 2, 1, -5, 4]"
        array_text = self.large_font.render(array_str, True, ORANGE)
        array_rect = array_text.get_rect(center=(WINDOW_WIDTH//2, 320))
        self.screen.blit(array_text, array_rect)
        
        # Opciones
        y = 400
        for i, option in enumerate(self.final_options):
            color = GOLD if i == self.selected_option else WHITE
            if self.show_result:
                if i == self.final_correct:
                    color = GREEN
                elif i == self.selected_option and not self.last_answer_correct:
                    color = RED
            
            text = self.font.render(option, True, color)
            text_rect = text.get_rect(center=(WINDOW_WIDTH//2, y))
            self.screen.blit(text, text_rect)
            y += 50
        
        if not self.show_result:
            instruction = self.small_font.render("Usa ↑↓ para seleccionar, ENTER para confirmar", True, WHITE)
            instruction_rect = instruction.get_rect(center=(WINDOW_WIDTH//2, 700))
            self.screen.blit(instruction, instruction_rect)
        else:
            if self.last_answer_correct:
                result_text = "¡Correcto! El subarreglo [4, -1, 2, 1] suma 6"
                result_color = GREEN
            else:
                result_text = "Incorrecto. La respuesta es A) 6. Inténtalo de nuevo."
                result_color = RED
            
            result = self.font.render(result_text, True, result_color)
            result_rect = result.get_rect(center=(WINDOW_WIDTH//2, 600))
            self.screen.blit(result, result_rect)
            
            continue_text = self.small_font.render("Presiona ESPACIO para continuar", True, WHITE)
            continue_rect = continue_text.get_rect(center=(WINDOW_WIDTH//2, 650))
            self.screen.blit(continue_text, continue_rect)
    
    def draw_victory(self):
        self.screen.fill((20, 80, 20))  # Verde triunfo
        
        # Título
        title = self.large_font.render("¡Victoria!", True, GOLD)
        title_rect = title.get_rect(center=(WINDOW_WIDTH//2, 150))
        self.screen.blit(title, title_rect)
        
        victory_text = [
            "¡Todas las Illas han sido recuperadas!",
            "",
            "El Tumi vuelve a la tierra para proteger,",
            "el perro viringo a su sitio,",
            "y el maíz y la papa regresan para fertilizar el suelo.",
            "",
            "El equilibrio está a salvo gracias a Ekeko y Ai Apaec.",
            "El conocimiento en todas sus formas",
            "es la clave para mantener la armonía.",
            "",
            "Presiona ESPACIO para jugar de nuevo"
        ]
        
        y = 250
        for line in victory_text:
            if line:
                text = self.font.render(line, True, WHITE)
                text_rect = text.get_rect(center=(WINDOW_WIDTH//2, y))
                self.screen.blit(text, text_rect)
            y += 35
    
    def wrap_text(self, text, font, max_width):
        words = text.split(' ')
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if font.size(test_line)[0] < max_width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line.strip())
                current_line = word + " "
        
        if current_line:
            lines.append(current_line.strip())
        
        return lines
    
    def update(self):
        # Actualizar lógica del juego si es necesario
        pass
    
    def draw(self):
        if self.state == GameState.INTRO:
            self.draw_intro()
        elif self.state == GameState.MAP:
            self.draw_map()
        elif self.state == GameState.QUIZ:
            self.draw_quiz()
        elif self.state == GameState.FINAL_CHALLENGE:
            self.draw_final_challenge()
        elif self.state == GameState.VICTORY:
            self.draw_victory()
        
        pygame.display.flip()
    
    def run(self):
        running = True
        while running:
            running = self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()
        sys.exit()

# Ejecutar el juego
if __name__ == "__main__":
    game = Game()
    game.run()
